<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gals! The Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="flex items-center justify-center min-h-screen bg-black">
  <div id="menu" class="fixed inset-0 flex items-center justify-center bg-gray-800 bg-opacity-80" style="display: none;">
    <div class="max-w-sm bg-white border border-gray-200 rounded-lg shadow dark:bg-gray-800 dark:border-gray-700">
        <div class="p-5">
            <h5 class="mb-2 text-2xl font-bold tracking-tight text-gray-900 dark:text-white">Gals! The Game</h5>
            <h6 class="mb-2 text-lg font-medium text-gray-900 dark:text-white">The UFOs are trying to kill the first chicken on the moon, use the gravity and your best skills to avoid'em! But be careful, some of them are faster.</h6>
            <img class="rounded-t-lg mb-4" src="/assets/level3.gif" alt="Game GIF" />
            <div class="pb-4">
                <kbd class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg dark:bg-gray-600 dark:text-gray-100 dark:border-gray-500">W</kbd>
                <kbd class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg dark:bg-gray-600 dark:text-gray-100 dark:border-gray-500">A</kbd>
                <kbd class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg dark:bg-gray-600 dark:text-gray-100 dark:border-gray-500">S</kbd>
                <kbd class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg dark:bg-gray-600 dark:text-gray-100 dark:border-gray-500">D</kbd>
                <kbd class="p-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg dark:bg-gray-600 dark:text-gray-100 dark:border-gray-500">SPACE</kbd>
            </div>
            <div class="flex flex-col space-y-4">
                <button id="restartButton" class="inline-flex items-center justify-center px-4 py-2 text-sm font-medium text-center text-white bg-blue-700 rounded-lg hover:bg-blue-800 focus:ring-4 focus:outline-none focus:ring-blue-300 dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800">
                    Restart
                </button>
                <button id="startButton" class="inline-flex items-center justify-center px-4 py-2 text-sm font-medium text-center text-white bg-blue-700 rounded-lg hover:bg-blue-800 focus:ring-4 focus:outline-none focus:ring-blue-300 dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800">
                    Start
                </button>
                <button id="menuButton" onclick="window.location.href='/index.html';" class="inline-flex items-center justify-center px-4 py-2 text-sm font-medium text-center text-white bg-blue-700 rounded-lg hover:bg-blue-800 focus:ring-4 focus:outline-none focus:ring-blue-300 dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800">
                    Go to Menu
                </button>
            </div>
        </div>
    </div>
</div>

  <script
    async
    src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"
  ></script>
    
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
      }
    }
  </script>
  
</body>
</html>

    <script type="module">
      import * as THREE from 'three';
      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(4.61, 2.74, 8);
      const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      renderer.shadowMap.enabled = true;
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);

      // Load a moon texture
      const textureLoader = new THREE.TextureLoader();
      const moonTexture = textureLoader.load('/assets/moonTexture.jpg'); // Path to your moon texture
      moonTexture.wrapS = THREE.RepeatWrapping;
      moonTexture.wrapT = THREE.RepeatWrapping;
      moonTexture.repeat.set(20, 20);

      // Create a sphere with the moon texture
      const moonGeometry = new THREE.SphereGeometry(200, 200, 200); // Adjust the radius and detail as needed
      const moonMaterial = new THREE.MeshStandardMaterial({ map: moonTexture });
      const moonSphere = new THREE.Mesh(moonGeometry, moonMaterial);

      // Position the moon sphere in the scene
      moonSphere.position.set(-5, -200.5, -10); // Position to avoid collisions with other objects
      moonSphere.rotation.x = Math.PI / 4; // Initial rotation along the x-axis
      scene.add(moonSphere);

      // Example Sketchfab model download URI
      const modelDownloadUri = 'assets/scene.gltf';
      const modelDownloadSpaceHelmet = 'assets/space_helmet/scene.gltf';
      const modelDownloadCar = 'assets/car/scene.gltf';
      const modelDownloadForest = 'assets/planet_earth/scene.gltf';
      const modelDownloadSun = 'assets/sun/scene.gltf';
      const modelDownloadUFO = 'assets/ufo/scene.gltf';
      const modelDownloadUFO2 = 'assets/ufo_2/scene.gltf';

      let chickenModel;
      let UFOModel;
      let UFOModel2;
      let carModel;
      let spaceHelmetModel;
      let forestModel;
      let sunModel;
      let moonModel;
      const walls = [];

      const loader = new GLTFLoader();
      loader.load(modelDownloadUri, function (gltf) {
          chickenModel = gltf.scene;
          chickenModel.scale.set(2, 2, 2);
          scene.add(chickenModel);
          
          chickenModel.position.set(0, 0, 0);

          // Rotate the chicken
          chickenModel.rotation.y = -Math.PI / 2; 
      }, undefined, function (error) {
          console.error(error);
      });

      loader.load(modelDownloadSpaceHelmet, function (gltf) {
          spaceHelmetModel = gltf.scene;
          spaceHelmetModel.scale.set(0.3, 0.3, 0.3);
          spaceHelmetModel.rotation.y = - Math.PI / 2;
          
          spaceHelmetModel.position.set(0, 0, 0);
            scene.add(spaceHelmetModel);
          // Rotate the car
          carModel.rotation.y = -Math.PI; 
      }, undefined, function (error) {
          console.error(error);
      });

      loader.load(modelDownloadSun, function (gltf) {
          sunModel = gltf.scene;
          sunModel.scale.set(0.5, 0.5 , 0.5);
          
          sunModel.position.set( 0 , 200, 400);
          scene.add(sunModel);

      }, undefined, function (error) {
          console.error(error);
      });

      loader.load(modelDownloadForest, function (gltf) {
          forestModel = gltf.scene;
          forestModel.scale.set(10, 10, 10);
          
          forestModel.position.set(0,3.2, -400);
          scene.add(forestModel);
          // Rotate the car 
      }, undefined, function (error) {
          console.error("Forest Error Loading: " , error);
      });

      loader.load(modelDownloadUFO, function (gltf) {
          UFOModel = gltf.scene;
          UFOModel.scale.set(0.005, 0.005 , 0.005);
          
          UFOModel.position.set(0,0,0);

      }, undefined, function (error) {
          console.error(error);
      });

      loader.load(modelDownloadUFO2, function (gltf) {
          UFOModel2 = gltf.scene;
          UFOModel2.scale.set(0.005, 0.005 , 0.005);
          
          UFOModel2.position.set(0,0,0);

      }, undefined, function (error) {
          console.error(error);
      });

      class Box extends THREE.Mesh {
        constructor({
          width,
          height,
          depth,
          transparent = true,
          color = '#ff0000',
          texture = null,
          gravity = true,
          opacity = 1,
          shot = false,
          velocity = {
            x: 0,
            y: 0,
            z: 0
          },
          position = {
            x: 0,
            y: 0,
            z: 0
          },
          rotation = {
            x: 0,
            y: 0,
            z: 0
          },
          zAcceleration = false
        }) {
          if (texture) {
            super(
              new THREE.BoxGeometry(width, height, depth),
              new THREE.MeshStandardMaterial({ map: texture })
            )
          } else {
            super(
              new THREE.BoxGeometry(width, height, depth),
              new THREE.MeshStandardMaterial({ color, transparent: transparent, opacity: opacity })
            )
          }
         
    
          this.width = width
          this.height = height
          this.depth = depth
          
          this.rotation.x = rotation.x
          this.rotation.y = rotation.y
          this.rotation.z = rotation.z

          this.position.set(position.x, position.y, position.z)
    
          this.right = this.position.x + this.width / 2
          this.left = this.position.x - this.width / 2
    
          this.bottom = this.position.y - this.height / 2
          this.top = this.position.y + this.height / 2
    
          this.front = this.position.z + this.depth / 2
          this.back = this.position.z - this.depth / 2
    
          this.velocity = velocity
          if (gravity){
            this.gravity = -0.0002
          } else {
            this.gravity = 0
          }
          this.zAcceleration = zAcceleration
        }
    
        updateSides() {
          this.right = this.position.x + this.width / 2
          this.left = this.position.x - this.width / 2
    
          this.bottom = this.position.y - this.height / 2
          this.top = this.position.y + this.height / 2
    
          this.front = this.position.z + this.depth / 2
          this.back = this.position.z - this.depth / 2
        }
    
        update(ground) {
          this.updateSides()
    
          if (this.zAcceleration) this.velocity.z += 0.0003
    
          this.position.x += this.velocity.x
          this.position.z += this.velocity.z
    
          this.applyGravity(ground)
        }
    
        applyGravity(ground) {
          this.velocity.y += this.gravity
    
          if (
            boxCollision({
              box1: this,
              box2: ground
            })
          ) {
            const friction = 0.5
            this.velocity.y *= friction
            this.velocity.y = -this.velocity.y
          } else this.position.y += this.velocity.y
        }
      }

      function setScore(score) {
        let scores = JSON.parse(localStorage.getItem('level-scores'));
        let nickname = localStorage.getItem('nickname');
        const newScore = { "nickname": nickname, "score": score};
        scores['Level 3'].push(newScore);

        localStorage.setItem('level-scores', JSON.stringify(scores));
      }

      let score = 0; // Initialize the score
      let scoreDisplay = document.createElement('div'); // Create a DOM element to display the score
      scoreDisplay.style.position = 'absolute';
      scoreDisplay.style.top = '10px';
      scoreDisplay.style.left = '10px';
      scoreDisplay.style.color = '#ffffff';
      scoreDisplay.style.fontFamily = 'Arial';
      scoreDisplay.style.fontSize = '24px';
      document.body.appendChild(scoreDisplay); // Append the score display to the document body

      function updateScore() {
        score++;
        scoreDisplay.textContent = `Score: ${score}`;
      }

      const groundtexture = new THREE.TextureLoader().load('/assets/moonTexture.jpg');
      groundtexture.wrapS = THREE.RepeatWrapping;
      groundtexture.wrapT = THREE.RepeatWrapping;
      groundtexture.repeat.set(3, 4);

      const ground = new Box({
        width: 50,
        height: 0.1,
        depth: 50,
        color: '#ffffff',
        opacity: 0,
        position: {
          x: 0,
          y: -1,
          z: -15
        },
        rotation: {
          x: 0,
          y: -Math.PI / 2,
          z: 0,
        }
      })
      scene.add(ground)
    
      function boxCollision({ box1, box2 }) {
        if (box2.passable) {
              return false;
        } else {
        const xCollision = box1.right >= box2.left && box1.left <= box2.right
        const yCollision =
          box1.bottom + box1.velocity.y <= box2.top && box1.top >= box2.bottom
        const zCollision = box1.front >= box2.back && box1.back <= box2.front
        return xCollision && yCollision && zCollision
        }
      }

      function wallCollision(box1){
        if (chickenCube.position.x > 5 || chickenCube.position.x < -5 || chickenCube.position.z > 8 || chickenCube.position.z < -30){
        return true;
        }
        return false;
      }
      
      const light = new THREE.DirectionalLight(0xffffff, 1)
      light.position.y = 3
      light.position.z = 1
      light.castShadow = true
      scene.add(light)
    
      scene.add(new THREE.AmbientLight(0xffffff, 0.5))
    
      camera.position.z = 5
    
      const keys = {
        a: {
          pressed: false
        },
        d: {
          pressed: false
        },
        s: {
          pressed: false
        },
        w: {
          pressed: false
        }
      }
    
      let doubleJumpAvailable = true; // Flag to check if double jump is available

      window.addEventListener('keydown', (event) => {
        switch (event.code) {
          case 'KeyA':
            keys.a.pressed = true;
            break;
          case 'KeyD':
            keys.d.pressed = true;
            break;
          case 'KeyS':
            keys.s.pressed = true;
            break;
          case 'KeyW':
            keys.w.pressed = true;
            break;
          case 'Space':
            if (doubleJumpAvailable) {
              chickenCube.velocity.y = 0.05;
              doubleJumpAvailable = false;
              setTimeout(() => {
                doubleJumpAvailable = true;
              }, 5000);
            }
            break;
        }
      });
        
      window.addEventListener('keyup', (event) => {
        switch (event.code) {
          case 'KeyA':
            keys.a.pressed = false
            break
          case 'KeyD':
            keys.d.pressed = false
            break
          case 'KeyS':
            keys.s.pressed = false
            break
          case 'KeyW':
            keys.w.pressed = false
            break
        }
      })
    
      const ufos = []

      const chickenCube = new Box({
        width: 0.6,
        height: 1,
        opacity: 0,
        depth: 0.5,
        gravity: true,
        velocity: {
          x: 0,
          y: 0,
          z: 0
        },
        position: {
          x: 0,
          y: 0,
          z: 0
        },
      })
      chickenCube.rotation.y = -Math.PI / 2 
      scene.add(chickenCube)

      let animationId; // Declare animationId outside the animate function

      let frames = 0
      let spawnRate = 400
      function animate() {
        animationId = requestAnimationFrame(animate)
        renderer.render(scene, camera)
    
        // movement code
        chickenCube.velocity.x = 0
        chickenCube.velocity.z = 0
        if (keys.a.pressed) chickenCube.velocity.x = -0.05
        else if (keys.d.pressed) chickenCube.velocity.x = 0.05
    
        if (keys.s.pressed) chickenCube.velocity.z = 0.05
        else if (keys.w.pressed) chickenCube.velocity.z = -0.05
    
        chickenCube.update(ground)
        if (chickenModel) {
          spaceHelmetModel.position.x = chickenCube.position.x
            spaceHelmetModel.position.y = chickenCube.position.y - 0.2
            spaceHelmetModel.position.z = chickenCube.position.z - 0.2
          chickenModel.position.x = chickenCube.position.x 
          chickenModel.position.y = chickenCube.position.y - 0.2 
          chickenModel.position.z = chickenCube.position.z - 0.2
        }
        ufos.forEach((ufo) => {
          updateScore();
          if (ufo.position.z > 100){
            scene.remove(ufo)
            ufos.splice(ufos.indexOf(ufo), 1)
          }
          ufo.update(ground)
          if (
            boxCollision({
              box1: chickenCube,
              box2: ufo
            })
          ) {
            console.log('ufo')
            cancelAnimationFrame(animationId)
            setScore(score);
            showMenu("restart");
          }
        })
        
      
        
        if (wallCollision({box1: chickenCube, walls: walls})) {
          chickenCube.position.x = chickenCube.position.x > 5 ? 5 : -5;
        }
        if (score >= 150000 ) {
          spawnRate = 100; 
        }
        if (score >= 300000 ) {
          spawnRate = 50; 
        }
        if (score >= 1000000 ) {
          spawnRate = 25; 
        }

        



        if (frames % spawnRate === 0 && spawnRate > 0) {
          if (spawnRate > 5 || spawnRate < 165) spawnRate -= 5
          
          var textureLoader = new THREE.TextureLoader();
          if (Math.random() < 0.5){
          const ufo = new Box({
            width: 1,
            height: 1.5,
            opacity: 0,
            depth: 1,
            transparent:true,
            gravity: false,
            shoot: false,
            position: {
              x: (Math.random() - 0.5) * 10,
              y: 0 ,
              z: -20
            },
            velocity: {
              x: 0,
              y: 0,
              z: 0.005
            },
            zAcceleration: true
          })
          ufo.add(UFOModel.clone());
          scene.add(ufo)
          ufos.push(ufo)
        } else {


          const ufo2 = new Box({
            width: 1,
            height: 1.5,
            opacity: 0,
            depth: 1,
            transparent:true,
            gravity: false,
            position: {
              x: (Math.random() - 0.5) * 10,
              y: 0.5,
              z: -20
            },
            velocity: {
              x: 0,
              y: 0,
              z: 0.04
            },
            zAcceleration: true
          })
          ufo2.add(UFOModel2.clone());
          scene.add(ufo2)
          ufos.push(ufo2)
          
          }
        } 
        frames++
      }

      function showMenu(restart) {
        document.getElementById('menu').style.display = 'flex';
        if (restart === "restart") {
          document.getElementById('restartButton').style.display = 'flex';
          document.getElementById('startButton').style.display = 'none';
        } else {
          document.getElementById('restartButton').style.display = 'none';
          document.getElementById('startButton').style.display = 'flex';
        }
      }



      document.getElementById('startButton').addEventListener('click', () => {
        document.getElementById('menu').style.display = 'none';
        setTimeout(100)
        animate();
      });


      document.getElementById('restartButton').addEventListener('click', () => {
        location.reload();
      });

      showMenu();
    </script>
</body>
</html>
