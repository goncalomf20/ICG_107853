<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gals!</title>
</head>
<body>
    <style>
        body {
          margin: 0;
          background: #77c3ec;
        }
    </style>
      
    <script
      async
      src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"
    ></script>
      
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
        }
      }
    </script>
      
    <script type="module">
      import * as THREE from 'three';
      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(4.61, 2.74, 8);
      const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      renderer.shadowMap.enabled = true;
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);

      // Example Sketchfab model download URI
      const modelDownloadUri = 'assets/scene.gltf';
      const modelDownloadCar = 'assets/car/scene.gltf';
      const modelDownloadForest = 'assets/forest/scene.gltf'
      const modelDownloadSun = 'assets/sun/scene.gltf'

      let chickenModel;
      let carModel;
      let forestModel;
      let sunModel;
      const walls = []

      const loader = new GLTFLoader();
      loader.load(modelDownloadUri, function (gltf) {
          chickenModel = gltf.scene;
          chickenModel.scale.set(2, 2, 2);
          scene.add(chickenModel);
          
          chickenModel.position.set(0, 0, 0);

          // Rotate the chicken
          chickenModel.rotation.y = -Math.PI / 2; 
      }, undefined, function (error) {
          console.error(error);
      });

      loader.load(modelDownloadCar, function (gltf) {
          carModel = gltf.scene;
          carModel.scale.set(0.0089, 0.0089, 0.0089);
          
          carModel.position.set(0, 0, 0);

          // Rotate the car
          carModel.rotation.y = -Math.PI; 
      }, undefined, function (error) {
          console.error(error);
      });
      
      loader.load(modelDownloadSun, function (gltf) {
          sunModel = gltf.scene;
          sunModel.scale.set(0.5, 0.5 , 0.5);
          
          sunModel.position.set( 0 , 200, -400);
          scene.add(sunModel);

      }, undefined, function (error) {
          console.error(error);
      });
      
      loader.load(modelDownloadForest, function (gltf) {
          forestModel = gltf.scene;
          forestModel.scale.set(1, 1, 1);
          
          forestModel.position.set(0,3.2, -170);
          scene.add(forestModel);
          // Rotate the car 
      }, undefined, function (error) {
          console.error("Forest Error Loading: " , error);
      });

      

      


      class Box extends THREE.Mesh {
        constructor({
          width,
          height,
          depth,
          transparent = true,
          color = '#ff0000',
          texture = null,
          opacity = 1,
          velocity = {
            x: 0,
            y: 0,
            z: 0
          },
          position = {
            x: 0,
            y: 0,
            z: 0
          },
          rotation = {
            x: 0,
            y: 0,
            z: 0
          },
          zAcceleration = false
        }) {
          if (texture) {
            super(
              new THREE.BoxGeometry(width, height, depth),
              new THREE.MeshStandardMaterial({ map: texture })
            )
          } else {
            super(
              new THREE.BoxGeometry(width, height, depth),
              new THREE.MeshStandardMaterial({ color, transparent: transparent, opacity: opacity })
            )
          }
         
    
          this.width = width
          this.height = height
          this.depth = depth
          
          this.rotation.x = rotation.x
          this.rotation.y = rotation.y
          this.rotation.z = rotation.z

          this.position.set(position.x, position.y, position.z)
    
          this.right = this.position.x + this.width / 2
          this.left = this.position.x - this.width / 2
    
          this.bottom = this.position.y - this.height / 2
          this.top = this.position.y + this.height / 2
    
          this.front = this.position.z + this.depth / 2
          this.back = this.position.z - this.depth / 2
    
          this.velocity = velocity
          this.gravity = -0.002
    
          this.zAcceleration = zAcceleration
        }
    
        updateSides() {
          this.right = this.position.x + this.width / 2
          this.left = this.position.x - this.width / 2
    
          this.bottom = this.position.y - this.height / 2
          this.top = this.position.y + this.height / 2
    
          this.front = this.position.z + this.depth / 2
          this.back = this.position.z - this.depth / 2
        }
    
        update(ground) {
          this.updateSides()
    
          if (this.zAcceleration) this.velocity.z += 0.0003
    
          this.position.x += this.velocity.x
          this.position.z += this.velocity.z
    
          this.applyGravity(ground)
        }
    
        applyGravity(ground) {
          this.velocity.y += this.gravity
    
          if (
            boxCollision({
              box1: this,
              box2: ground
            })
          ) {
            const friction = 0.5
            this.velocity.y *= friction
            this.velocity.y = -this.velocity.y
          } else this.position.y += this.velocity.y
        }
      }
      let score = 0; // Initialize the score
        let scoreDisplay = document.createElement('div'); // Create a DOM element to display the score
        scoreDisplay.style.position = 'absolute';
        scoreDisplay.style.top = '10px';
        scoreDisplay.style.left = '10px';
        scoreDisplay.style.color = '#ffffff';
        scoreDisplay.style.fontFamily = 'Arial';
        scoreDisplay.style.fontSize = '24px';
        document.body.appendChild(scoreDisplay); // Append the score display to the document body

        function updateScore() {
          score++;
          scoreDisplay.textContent = `Score: ${score}`;
        }

      const groundtexture = new THREE.TextureLoader().load('/assets/foresttexture.jpg');
      groundtexture.wrapS = THREE.RepeatWrapping;
      groundtexture.wrapT = THREE.RepeatWrapping;
      groundtexture.repeat.set(10, 10);

      const ground = new Box({
        width: 50,
        height: 0.5,
        depth: 50,
        color: '#288C1E',
        opacity: 0.1,
        position: {
          x: 0,
          y: -1,
          z: -15
        },
        rotation: {
          x: 0,
          y: -Math.PI / 2,
          z: 0,
        }
        
      })
      scene.add(ground)
    
      function boxCollision({ box1, box2 }) {
        if (box2.passable) {
              return false;
        }
        else{
        const xCollision = box1.right >= box2.left && box1.left <= box2.right
        const yCollision =
          box1.bottom + box1.velocity.y <= box2.top && box1.top >= box2.bottom
        const zCollision = box1.front >= box2.back && box1.back <= box2.front
        return xCollision && yCollision && zCollision
        }
      }

      function wallCollision(box1){
        if (chickenCube.position.x > 5 || chickenCube.position.x < -5 || chickenCube.position.z > 8 || chickenCube.position.z < -30){
        return true;
        }
        return false;
      }
      
      const light = new THREE.DirectionalLight(0xffffff, 1)
      light.position.y = 3
      light.position.z = 1
      light.castShadow = true
      scene.add(light)
    
      scene.add(new THREE.AmbientLight(0xffffff, 0.5))
    
      camera.position.z = 5
    
      const keys = {
        a: {
          pressed: false
        },
        d: {
          pressed: false
        },
        s: {
          pressed: false
        },
        w: {
          pressed: false
        }
      }
    
      let doubleJumpAvailable = true; // Flag to check if double jump is available

      window.addEventListener('keydown', (event) => {
        switch (event.code) {
          case 'KeyA':
            keys.a.pressed = true;
            break;
          case 'KeyD':
            keys.d.pressed = true;
            break;
          case 'KeyS':
            keys.s.pressed = true;
            break;
          case 'KeyW':
            keys.w.pressed = true;
            break;
          case 'Space':
            if (doubleJumpAvailable) {
              chickenCube.velocity.y = 0.1;
              doubleJumpAvailable = false;
              setTimeout(() => {
                doubleJumpAvailable = true;
              }, 2000);
            }
            break;
        }
      });
        
      window.addEventListener('keyup', (event) => {
        switch (event.code) {
          case 'KeyA':
            keys.a.pressed = false
            break
          case 'KeyD':
            keys.d.pressed = false
            break
          case 'KeyS':
            keys.s.pressed = false
            break
          case 'KeyW':
            keys.w.pressed = false
            break
        }
      })
    
      const logs = []
      const cars = []

      const chickenCube = new Box({
        width: 0.6,
        height: 1,
        opacity: 0,
        depth: 0.5,
        velocity: {
          x: 0,
          y: 0,
          z: 0
        },
        position: {
          x: 0,
          y: 0,
          z: 0
        },
      })
      chickenCube.rotation.y = -Math.PI / 2 
      scene.add(chickenCube)

    
      let frames = 0
      let spawnRate = 400
      function animate() {
        const animationId = requestAnimationFrame(animate)
        renderer.render(scene, camera)
    
        // movement code
        chickenCube.velocity.x = 0
        chickenCube.velocity.z = 0
        if (keys.a.pressed) chickenCube.velocity.x = -0.05
        else if (keys.d.pressed) chickenCube.velocity.x = 0.05
    
        if (keys.s.pressed) chickenCube.velocity.z = 0.05
        else if (keys.w.pressed) chickenCube.velocity.z = -0.05
    
        chickenCube.update(ground)
        if (chickenModel) {
          chickenModel.position.x = chickenCube.position.x 
          chickenModel.position.y = chickenCube.position.y - 0.2 
          chickenModel.position.z = chickenCube.position.z - 0.2
        }
        logs.forEach((log) => {
          updateScore();
          log.update(ground)
          if (
            boxCollision({
              box1: chickenCube,
              box2: log
            })
          ) {
            cancelAnimationFrame(animationId)
          }
        })
        
        if (wallCollision({box1: chickenCube, walls: walls})) {
          cancelAnimationFrame(animationId)
        }


                

        // if (frames % spawnRate === 0) {
        //     if (spawnRate > 20) spawnRate -= 20;

        //     const c = new Box({
        //         width: 2,
        //         height: 1,
        //         depth: 1,
        //         transparent: false,
        //         position: {
        //             x: 10, 
        //             y: 1,
        //             z: (Math.random() - 0.5) * 8, 
        //         },
        //         velocity: {
        //             x: -0.1,
        //             y: 0,
        //             z: 0, // Adjust z velocity for car speed
        //         },
        //         zAcceleration: false // No need for z acceleration for cars
        //     });
        //     c.add(carModel.clone());
        //     scene.add(c);
        //     cars.push(c); 
        // }

        cars.forEach((car) => {
            car.update(ground);
            if (
                boxCollision({
                    box1: chickenCube,
                    box2: car
                })
            ) {
                cancelAnimationFrame(animationId);
            }
            // Remove cars that move out of view
            if (car.position.z > 10) {
                scene.remove(car);
                const index = cars.indexOf(car);
                if (index > -1) {
                    cars.splice(index, 1);
                }
            }
        });
        
        
    
        if (frames % spawnRate === 0) {
          if (spawnRate > 5) spawnRate -= 5
          
          var textureLoader = new THREE.TextureLoader();

          const log = new Box({
            width: 2,
            height: 1,
            opacity: 0,
            depth: 1,
            texture: textureLoader.load('assets/woodtexture.jpg'),
            transparent:false,
            position: {
              x: (Math.random() - 0.5) * 10,
              y: 0,
              z: -20
            },
            velocity: {
              x: 0,
              y: 0,
              z: 0.005
            },
            zAcceleration: true
          })
          scene.add(log)
          logs.push(log)
          
        } 
       
        const car = new Box({
            width: 2,
            height: 1,
            opacity: 0,
            depth: 1,
            transparent:false,
            position: {
              x: (Math.random() - 0.5) * 10,
              y: 0,
              z: -20
            },
            velocity: {
              x: 0,
              y: 0,
              z: 0.005
            },
            zAcceleration: true
          })
    
        frames++
        
      }
      animate()
    </script>
</body>
</html>
